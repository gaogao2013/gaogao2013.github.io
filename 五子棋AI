<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸“ä¸šäº”å­æ£‹AI - Minimax Alpha-Betaä¼˜åŒ–ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            color: #666;
            font-size: 1.1em;
        }
        
        .game-area {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .left-panel {
            flex: 2;
            min-width: 500px;
        }
        
        .right-panel {
            flex: 1;
            min-width: 300px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f0f7ff, #e3f2fd);
            border-radius: 10px;
            border-left: 5px solid #2196F3;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .player-indicator {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.3em;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }
        
        .black-indicator {
            background: linear-gradient(135deg, #333, #000);
            color: white;
            border: 3px solid #666;
        }
        
        .white-indicator {
            background: linear-gradient(135deg, #fff, #f5f5f5);
            color: #333;
            border: 3px solid #ddd;
        }
        
        .board-container {
            position: relative;
            background: linear-gradient(135deg, #deb887, #cd853f);
            padding: 25px;
            border-radius: 15px;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
        }
        
        #boardCanvas {
            display: block;
            background: #f0d9b5;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .ai-thinking {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
            align-items: center;
            gap: 15px;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .forbidden-warning {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            border: 2px solid #f44336;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 14px 28px;
            font-size: 1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .primary-btn {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, #2196F3, #1565C0);
            color: white;
        }
        
        .ai-btn {
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
            color: white;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .ai-controls {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .ai-controls h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ai-level-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .level-btn {
            flex: 1;
            padding: 12px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .level-btn:hover {
            background: #e3f2fd;
            border-color: #2196F3;
        }
        
        .level-btn.active {
            background: #2196F3;
            color: white;
            border-color: #1565C0;
            font-weight: bold;
        }
        
        .value-table {
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .value-table h4 {
            color: #333;
            margin-bottom: 10px;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        
        .value-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .value-item:last-child {
            border-bottom: none;
        }
        
        .pattern-name {
            font-weight: bold;
        }
        
        .pattern-value {
            color: #2196F3;
            font-weight: bold;
        }
        
        .move-history {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
        }
        
        .history-title {
            color: #333;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #2196F3;
        }
        
        .history-item.ai-move {
            border-left-color: #9C27B0;
            background: #f3e5f5;
        }
        
        .ai-stats {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9em;
            color: #666;
        }
        
        @media (max-width: 1100px) {
            .game-area {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                min-width: 100%;
            }
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            #boardCanvas {
                width: 350px !important;
                height: 350px !important;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– ä¸“ä¸šäº”å­æ£‹AI - Minimax Alpha-Betaä¼˜åŒ–ç‰ˆ</h1>
            <p class="subtitle">æ™ºèƒ½æœç´¢ç®—æ³• + å®Œæ•´ç¦æ‰‹è§„åˆ™ + æ·±åº¦æ€è€ƒç­–ç•¥</p>
        </div>
        
        <div class="game-area">
            <div class="left-panel">
                <div class="game-info">
                    <div class="player-info">
                        <div class="player-indicator black-indicator" id="currentPlayerIndicator">â—</div>
                        <div>
                            <div id="currentPlayerText">é»‘æ£‹ (ç©å®¶)</div>
                            <div id="gameStatus" style="font-size: 0.9em; color: #666;">æ¸¸æˆä¸­...</div>
                        </div>
                    </div>
                    <div id="scoreInfo" style="font-weight: bold; color: #2196F3;">
                        Minimax AI | æ·±åº¦: 4
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <div class="board-container">
                        <canvas id="boardCanvas" width="450" height="450"></canvas>
                    </div>
                </div>
                
                <div class="ai-thinking" id="aiThinking">
                    <div class="spinner"></div>
                    <span>ğŸ¤” AIæ­£åœ¨æ€è€ƒä¸­... æ·±åº¦: <span id="aiDepth">4</span></span>
                </div>
                
                <div class="forbidden-warning" id="forbiddenWarning">
                    <strong>âŒ ç¦æ‰‹é˜»æ­¢ï¼</strong>
                    <span id="forbiddenReason">æ­¤ä½ç½®è¿åç¦æ‰‹è§„åˆ™</span>
                </div>
                
                <div class="controls">
                    <button class="primary-btn" id="restartBtn">ğŸ”„ é‡æ–°å¼€å§‹</button>
                    <button class="secondary-btn" id="undoBtn">â†©ï¸ æ‚”æ£‹ä¸€æ­¥</button>
                    <button class="ai-btn" id="aiMoveBtn">ğŸ¤– AIèµ°ä¸€æ­¥</button>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="ai-controls">
                    <h3>âš™ï¸ AIè®¾ç½®</h3>
                    
                    <div class="ai-level-selector">
                        <div class="level-btn active" data-level="2">ä¸­ç­‰ (æ·±åº¦4)</div>
                        <div class="level-btn" data-level="1">ç®€å• (æ·±åº¦2)</div>
                        <div class="level-btn" data-level="3">å›°éš¾ (æ·±åº¦6)</div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label style="display: block; margin-bottom: 8px; color: #666;">
                            <input type="checkbox" id="autoAi" checked> è‡ªåŠ¨AIå¯¹æˆ˜
                        </label>
                        <label style="display: block; margin-bottom: 8px; color: #666;">
                            <input type="checkbox" id="showAnalysis"> æ˜¾ç¤ºåˆ†æä¿¡æ¯
                        </label>
                    </div>
                </div>
                
                <div class="value-table">
                    <h4>ğŸ“Š AIè¯„ä¼°æƒé‡ (Minimaxä¼˜åŒ–)</h4>
                    <div class="value-item">
                        <span class="pattern-name">è¿äº” (èƒœåˆ©)</span>
                        <span class="pattern-value">+1000000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">æ´»å››</span>
                        <span class="pattern-value">+50000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">å†²å››</span>
                        <span class="pattern-value">+10000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">æ´»ä¸‰</span>
                        <span class="pattern-value">+5000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">çœ ä¸‰</span>
                        <span class="pattern-value">+500</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">æ´»äºŒ</span>
                        <span class="pattern-value">+200</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">åŒä¸‰</span>
                        <span class="pattern-value">+20000</span>
                    </div>
                </div>
                
                <div id="aiStats" class="ai-stats" style="display: none;">
                    <div><strong>AIæ€è€ƒç»Ÿè®¡ï¼š</strong></div>
                    <div id="statsContent"></div>
                </div>
                
                <div class="move-history">
                    <div class="history-title">ğŸ“ èµ°æ£‹è®°å½•</div>
                    <div id="historyList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ProfessionalGomokuAI {
            constructor() {
                // æ£‹ç›˜å‚æ•°
                this.boardSize = 15;
                this.cellSize = 30;
                this.padding = 15;
                this.canvasSize = this.boardSize * this.cellSize + this.padding * 2;
                
                // æ¸¸æˆçŠ¶æ€
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1; // 1: ç©å®¶(é»‘), 2: AI(ç™½)
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.winningLine = [];
                
                // AIå‚æ•°
                this.aiLevel = 2;
                this.aiThinking = false;
                this.autoAI = true;
                this.showAnalysis = false;
                
                // æ€§èƒ½ç»Ÿè®¡
                this.searchNodeCount = 0;
                this.pruneCount = 0;
                this.searchStartTime = 0;
                
                // æ£‹å‹ä»·å€¼è¡¨ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
                this.patternScores = {
                    FIVE: 1000000,          // è¿äº”èƒœåˆ©
                    LIVE_FOUR: 50000,       // æ´»å››
                    SLEEP_FOUR: 10000,      // å†²å››
                    LIVE_THREE: 5000,       // æ´»ä¸‰
                    SLEEP_THREE: 500,       // çœ ä¸‰
                    LIVE_TWO: 200,          // æ´»äºŒ
                    SLEEP_TWO: 50,          // çœ äºŒ
                    
                    OPPONENT_LIVE_FOUR: 80000,     // å¯¹æ–¹æ´»å››
                    OPPONENT_SLEEP_FOUR: 40000,    // å¯¹æ–¹å†²å››
                    OPPONENT_LIVE_THREE: 15000,    // å¯¹æ–¹æ´»ä¸‰
                    
                    DOUBLE_THREE: 20000,           // åŒä¸‰
                    FOUR_THREE: 60000,             // å››ä¸‰
                };
                
                // éš¾åº¦å¯¹åº”çš„æœç´¢æ·±åº¦
                this.depthByLevel = {1: 2, 2: 4, 3: 6};
                
                // åˆå§‹åŒ–
                this.initialize();
            }
            
            initialize() {
                // è·å–DOMå…ƒç´ 
                this.canvas = document.getElementById('boardCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentPlayerText = document.getElementById('currentPlayerText');
                this.currentPlayerIndicator = document.getElementById('currentPlayerIndicator');
                this.gameStatus = document.getElementById('gameStatus');
                this.scoreInfo = document.getElementById('scoreInfo');
                this.forbiddenWarning = document.getElementById('forbiddenWarning');
                this.forbiddenReason = document.getElementById('forbiddenReason');
                this.aiThinkingDiv = document.getElementById('aiThinking');
                this.aiDepthSpan = document.getElementById('aiDepth');
                this.historyList = document.getElementById('historyList');
                this.aiStatsDiv = document.getElementById('aiStats');
                this.statsContent = document.getElementById('statsContent');
                
                // è®¾ç½®canvaså°ºå¯¸
                this.canvas.width = this.canvasSize;
                this.canvas.height = this.canvasSize;
                
                // ç»‘å®šäº‹ä»¶
                this.setupEventListeners();
                
                // å¼€å§‹æ¸¸æˆ
                this.resetGame();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                document.getElementById('restartBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('aiMoveBtn').addEventListener('click', () => this.makeAIMove());
                
                // éš¾åº¦é€‰æ‹©
                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.aiLevel = parseInt(btn.dataset.level);
                        this.aiDepthSpan.textContent = this.depthByLevel[this.aiLevel];
                        this.scoreInfo.textContent = `Minimax AI | æ·±åº¦: ${this.depthByLevel[this.aiLevel]}`;
                    });
                });
                
                // è‡ªåŠ¨AIå¼€å…³
                document.getElementById('autoAi').addEventListener('change', (e) => {
                    this.autoAI = e.target.checked;
                });
                
                // åˆ†ææ˜¾ç¤ºå¼€å…³
                document.getElementById('showAnalysis').addEventListener('change', (e) => {
                    this.showAnalysis = e.target.checked;
                });
            }
            
            // ============ æ¸¸æˆæ ¸å¿ƒé€»è¾‘ ============
            
            handleClick(e) {
                if (this.gameOver || this.aiThinking || this.currentPlayer !== 1) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const col = Math.round((x - this.padding) / this.cellSize);
                const row = Math.round((y - this.padding) / this.cellSize);
                
                if (row >= 0 && row < this.boardSize && col >= 0 && col < this.boardSize) {
                    this.tryMakeMove(row, col);
                }
            }
            
            tryMakeMove(row, col) {
                if (this.board[row][col] !== 0) {
                    this.showWarning("è¯¥ä½ç½®å·²æœ‰æ£‹å­ï¼");
                    return false;
                }
                
                // æ£€æŸ¥ç¦æ‰‹
                if (this.isForbiddenMove(row, col, this.currentPlayer)) {
                    return false;
                }
                
                this.executeMove(row, col, false);
                return true;
            }
            
            executeMove(row, col, isAIMove = false) {
                // è®°å½•èµ°æ£‹
                const moveNumber = this.moveHistory.length + 1;
                this.moveHistory.push({
                    row, col,
                    player: this.currentPlayer,
                    moveNumber,
                    isAIMove,
                    timestamp: Date.now()
                });
                
                // ä¸‹æ£‹
                this.board[row][col] = this.currentPlayer;
                
                // æ›´æ–°å†å²è®°å½•
                this.updateHistory();
                
                // æ£€æŸ¥èƒœåˆ©
                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.showWinMessage();
                    this.drawBoard();
                    return;
                }
                
                // åˆ‡æ¢ç©å®¶
                this.currentPlayer = 3 - this.currentPlayer;
                
                // æ›´æ–°ç•Œé¢
                this.drawBoard();
                this.updateStatus();
                
                // å¦‚æœæ˜¯ç©å®¶èµ°æ£‹ä¸”å¼€å¯äº†è‡ªåŠ¨AIï¼Œè®©AIèµ°æ£‹
                if (!isAIMove && this.autoAI && this.currentPlayer === 2 && !this.gameOver) {
                    setTimeout(() => this.makeAIMove(), 300);
                }
            }
            
            // ============ Minimax Alpha-Beta AIæ ¸å¿ƒç®—æ³• ============
            
            async makeAIMove() {
                if (this.gameOver || this.currentPlayer !== 2 || this.aiThinking) return;
                
                this.aiThinking = true;
                this.aiThinkingDiv.style.display = 'flex';
                
                // é‡ç½®ç»Ÿè®¡
                this.searchNodeCount = 0;
                this.pruneCount = 0;
                this.searchStartTime = Date.now();
                
                try {
                    const depth = this.depthByLevel[this.aiLevel];
                    const bestMove = this.findBestMoveWithMinimax(depth);
                    
                    if (bestMove) {
                        this.executeMove(bestMove.row, bestMove.col, true);
                        
                        // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                        if (this.showAnalysis) {
                            this.showAITimings();
                        }
                    }
                } catch (error) {
                    console.error('AIæ€è€ƒå‡ºé”™:', error);
                    // å‡ºé”™æ—¶ä½¿ç”¨ç®€å•ç®—æ³•
                    const simpleMove = this.findBestMoveSimple();
                    if (simpleMove) {
                        this.executeMove(simpleMove.row, simpleMove.col, true);
                    }
                } finally {
                    this.aiThinking = false;
                    this.aiThinkingDiv.style.display = 'none';
                }
            }
            
            findBestMoveWithMinimax(maxDepth) {
                // 1. æ£€æŸ¥ç«‹å³è·èƒœ
                const winMove = this.findImmediateWin(2);
                if (winMove) return winMove;
                
                // 2. ç´§æ€¥é˜²å®ˆ
                const blockMove = this.findImmediateWin(1);
                if (blockMove && !this.isForbiddenMove(blockMove.row, blockMove.col, 2)) {
                    return blockMove;
                }
                
                // 3. ä½¿ç”¨Minimax Alpha-Betaæœç´¢
                const candidateMoves = this.getCandidateMovesOptimized(2);
                
                let bestScore = -Infinity;
                let bestMove = null;
                let alpha = -Infinity;
                let beta = Infinity;
                
                for (const move of candidateMoves) {
                    const {row, col} = move;
                    
                    // è·³è¿‡ç¦æ‰‹ä½ç½®
                    if (this.isForbiddenMove(row, col, 2)) continue;
                    
                    // å°è¯•èµ°æ£‹
                    this.board[row][col] = 2;
                    
                    // Alpha-Betaå‰ªææœç´¢
                    const score = this.minimaxAlphaBeta(
                        maxDepth - 1, 
                        alpha, 
                        beta, 
                        false, // ä¸‹ä¸€æ­¥æ˜¯å¯¹æ‰‹
                        1      // å¯¹æ‰‹æ˜¯é»‘æ£‹
                    );
                    
                    // æ’¤é”€èµ°æ£‹
                    this.board[row][col] = 0;
                    
                    // æ›´æ–°æœ€ä½³èµ°æ³•
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = {row, col};
                        alpha = Math.max(alpha, score);
                    }
                    
                    if (beta <= alpha) {
                        this.pruneCount++;
                        break; // Betaå‰ªæ
                    }
                }
                
                return bestMove;
            }
            
            minimaxAlphaBeta(depth, alpha, beta, isMaximizing, player) {
                this.searchNodeCount++;
                
                // ç»ˆæ­¢æ¡ä»¶ï¼šè¾¾åˆ°æ·±åº¦é™åˆ¶æˆ–æ¸¸æˆç»“æŸ
                if (depth === 0 || this.isGameTerminal()) {
                    return this.evaluateBoard(player === 2);
                }
                
                const currentPlayer = isMaximizing ? 2 : 1;
                const candidateMoves = this.getCandidateMovesOptimized(currentPlayer);
                
                if (isMaximizing) {
                    let maxEval = -Infinity;
                    
                    for (const move of candidateMoves) {
                        const {row, col} = move;
                        
                        if (this.isForbiddenMove(row, col, currentPlayer)) continue;
                        
                        this.board[row][col] = currentPlayer;
                        
                        const evaluation = this.minimaxAlphaBeta(
                            depth - 1, 
                            alpha, 
                            beta, 
                            false, 
                            3 - currentPlayer
                        );
                        
                        this.board[row][col] = 0;
                        
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        
                        if (beta <= alpha) {
                            this.pruneCount++;
                            break; // Betaå‰ªæ
                        }
                    }
                    
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    
                    for (const move of candidateMoves) {
                        const {row, col} = move;
                        
                        if (this.isForbiddenMove(row, col, currentPlayer)) continue;
                        
                        this.board[row][col] = currentPlayer;
                        
                        const evaluation = this.minimaxAlphaBeta(
                            depth - 1, 
                            alpha, 
                            beta, 
                            true, 
                            3 - currentPlayer
                        );
                        
                        this.board[row][col] = 0;
                        
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        
                        if (beta <= alpha) {
                            this.pruneCount++;
                            break; // Alphaå‰ªæ
                        }
                    }
                    
                    return minEval;
                }
            }
            
            findImmediateWin(player) {
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            this.board[i][j] = player;
                            
                            if (this.checkWin(i, j)) {
                                this.board[i][j] = 0;
                                return {row: i, col: j};
                            }
                            
                            this.board[i][j] = 0;
                        }
                    }
                }
                return null;
            }
            
            isGameTerminal() {
                // æ£€æŸ¥æ˜¯å¦æœ‰äº”è¿
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            const player = this.board[i][j];
                            const directions = [[0,1], [1,0], [1,1], [1,-1]];
                            
                            for (const [dr, dc] of directions) {
                                let count = 1;
                                let r = i + dr, c = j + dc;
                                
                                while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                                       this.board[r][c] === player) {
                                    count++;
                                    r += dr;
                                    c += dc;
                                }
                                
                                r = i - dr;
                                c = j - dc;
                                while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                                       this.board[r][c] === player) {
                                    count++;
                                    r -= dr;
                                    c -= dc;
                                }
                                
                                if (count >= 5) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            evaluateBoard(isAITurn) {
                let score = 0;
                const aiPlayer = 2;
                const humanPlayer = 1;
                
                // è¯„ä¼°æ•´ä¸ªæ£‹ç›˜
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === aiPlayer) {
                            score += this.evaluatePosition(i, j, aiPlayer, true);
                        } else if (this.board[i][j] === humanPlayer) {
                            score -= this.evaluatePosition(i, j, humanPlayer, false) * 1.2;
                        }
                    }
                }
                
                return score;
            }
            
            evaluatePosition(row, col, player, isAI) {
                let score = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    const pattern = this.getDirectionPatternExtended(row, col, dr, dc, 9);
                    score += this.evaluatePattern(pattern, player, isAI);
                }
                
                // ä½ç½®ä¼˜åŠ¿
                const center = Math.floor(this.boardSize / 2);
                const dist = Math.abs(row - center) + Math.abs(col - center);
                score += (this.boardSize - dist) * 10;
                
                return score;
            }
            
            evaluatePattern(pattern, player, isAI) {
                const patternStr = pattern.map(cell => {
                    if (cell === player) return '1';
                    if (cell === 0) return '0';
                    return 'x';
                }).join('');
                
                let score = 0;
                
                // è¿äº”
                if (patternStr.includes('11111')) {
                    return this.patternScores.FIVE;
                }
                
                // æ´»å››
                if (patternStr.includes('011110')) {
                    score += isAI ? this.patternScores.LIVE_FOUR : this.patternScores.OPPONENT_LIVE_FOUR;
                }
                
                // å†²å››
                if (this.containsSleepFour(patternStr)) {
                    score += isAI ? this.patternScores.SLEEP_FOUR : this.patternScores.OPPONENT_SLEEP_FOUR;
                }
                
                // æ´»ä¸‰
                if (this.containsLiveThree(patternStr)) {
                    score += isAI ? this.patternScores.LIVE_THREE : this.patternScores.OPPONENT_LIVE_THREE;
                }
                
                // çœ ä¸‰
                if (this.containsSleepThree(patternStr)) {
                    score += this.patternScores.SLEEP_THREE;
                }
                
                // æ´»äºŒ
                if (this.containsLiveTwo(patternStr)) {
                    score += this.patternScores.LIVE_TWO;
                }
                
                return score;
            }
            
            containsSleepFour(patternStr) {
                const sleepFourPatterns = [
                    '011112', '211110',     // å•è¾¹å†²å››
                    '10111', '11101', '11011'  // è·³å†²å››
                ];
                
                for (const pattern of sleepFourPatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            containsLiveThree(patternStr) {
                const liveThreePatterns = [
                    '01110',     // ä¸­é—´æ´»ä¸‰
                    '010110',    // è·³æ´»ä¸‰
                    '011010',    // è·³æ´»ä¸‰
                    '0011100'    // å¦ä¸€ç§æ´»ä¸‰
                ];
                
                for (const pattern of liveThreePatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            containsSleepThree(patternStr) {
                const sleepThreePatterns = [
                    '01112', '21110',
                    '010112', '211010',
                    '011012', '210110'
                ];
                
                for (const pattern of sleepThreePatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            containsLiveTwo(patternStr) {
                const liveTwoPatterns = [
                    '001100', '01010', '010010',
                    '0010100', '00011000'
                ];
                
                for (const pattern of liveTwoPatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            getDirectionPatternExtended(row, col, dr, dc, length) {
                const pattern = [];
                const offset = Math.floor(length / 2);
                
                for (let i = -offset; i <= offset; i++) {
                    const r = row + dr * i;
                    const c = col + dc * i;
                    
                    if (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize) {
                        pattern.push(this.board[r][c]);
                    } else {
                        pattern.push(-1); // è¾¹ç•Œå¤–
                    }
                }
                
                return pattern;
            }
            
            getCandidateMovesOptimized(player) {
                const moves = [];
                const scores = [];
                const visited = new Set();
                
                // æœç´¢åŠå¾„
                const searchRadius = this.aiLevel === 3 ? 3 : 2;
                
                // ä¼˜å…ˆæœç´¢å·²æœ‰æ£‹å­å‘¨å›´
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            for (let di = -searchRadius; di <= searchRadius; di++) {
                                for (let dj = -searchRadius; dj <= searchRadius; dj++) {
                                    const ni = i + di;
                                    const nj = j + dj;
                                    
                                    if (ni >= 0 && ni < this.boardSize && nj >= 0 && nj < this.boardSize &&
                                        this.board[ni][nj] === 0) {
                                        const key = `${ni},${nj}`;
                                        if (!visited.has(key)) {
                                            visited.add(key);
                                            // è®¡ç®—ä½ç½®åˆ†æ•°ç”¨äºæ’åº
                                            const score = this.evaluateMovePotential(ni, nj, player);
                                            moves.push({row: ni, col: nj});
                                            scores.push(score);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰å€™é€‰ä½ç½®ï¼Œé€‰æ‹©ä¸­å¿ƒåŒºåŸŸ
                if (moves.length === 0) {
                    const center = Math.floor(this.boardSize / 2);
                    for (let i = center - 1; i <= center + 1; i++) {
                        for (let j = center - 1; j <= center + 1; j++) {
                            if (i >= 0 && i < this.boardSize && j >= 0 && j < this.boardSize &&
                                this.board[i][j] === 0) {
                                moves.push({row: i, col: j});
                            }
                        }
                    }
                }
                
                // æ ¹æ®åˆ†æ•°æ’åºï¼ˆæé«˜Alpha-Betaæ•ˆç‡ï¼‰
                const sortedIndices = scores.map((_, index) => index)
                    .sort((a, b) => scores[b] - scores[a]);
                
                return sortedIndices.map(idx => moves[idx]);
            }
            
            evaluateMovePotential(row, col, player) {
                let score = 0;
                
                // ä¸­å¿ƒä¼˜åŠ¿
                const center = Math.floor(this.boardSize / 2);
                const dist = Math.abs(row - center) + Math.abs(col - center);
                score += (this.boardSize - dist) * 10;
                
                // å‘¨è¾¹æ£‹å­å½±å“
                for (let i = Math.max(0, row - 2); i <= Math.min(this.boardSize - 1, row + 2); i++) {
                    for (let j = Math.max(0, col - 2); j <= Math.min(this.boardSize - 1, col + 2); j++) {
                        if (this.board[i][j] === player) {
                            const distance = Math.abs(i - row) + Math.abs(j - col);
                            score += (3 - distance) * 50;
                        } else if (this.board[i][j] === 3 - player) {
                            const distance = Math.abs(i - row) + Math.abs(j - col);
                            score += (3 - distance) * 30;
                        }
                    }
                }
                
                return score;
            }
            
            findBestMoveSimple() {
                // ç®€å•çš„å¨èƒæ£€æµ‹ä½œä¸ºå¤‡ç”¨
                const winMove = this.findImmediateWin(2);
                if (winMove) return winMove;
                
                const blockMove = this.findImmediateWin(1);
                if (blockMove && !this.isForbiddenMove(blockMove.row, blockMove.col, 2)) {
                    return blockMove;
                }
                
                // éšæœºé€‰æ‹©ä¸€ä¸ªå€™é€‰ä½ç½®
                const candidateMoves = this.getCandidateMovesOptimized(2);
                if (candidateMoves.length > 0) {
                    return candidateMoves[0];
                }
                
                return null;
            }
            
            showAITimings() {
                const searchTime = Date.now() - this.searchStartTime;
                
                this.statsContent.innerHTML = `
                    <div>æœç´¢æ—¶é—´: ${searchTime}ms</div>
                    <div>æœç´¢èŠ‚ç‚¹æ•°: ${this.searchNodeCount}</div>
                    <div>å‰ªææ¬¡æ•°: ${this.pruneCount}</div>
                    <div>æœç´¢æ·±åº¦: ${this.depthByLevel[this.aiLevel]}</div>
                `;
                
                this.aiStatsDiv.style.display = 'block';
                
                // 5ç§’åéšè—ç»Ÿè®¡ä¿¡æ¯
                setTimeout(() => {
                    if (this.aiStatsDiv) {
                        this.aiStatsDiv.style.display = 'none';
                    }
                }, 5000);
            }
            
            // ============ ç¦æ‰‹æ£€æµ‹ ============
            isForbiddenMove(row, col, player) {
                if (this.board[row][col] !== 0) return false;
                
                this.board[row][col] = player;
                
                let isForbidden = false;
                let reason = "";
                
                // é•¿è¿ç¦æ‰‹
                const longChain = this.checkLongChain(row, col, player);
                if (longChain > 5) {
                    isForbidden = true;
                    reason = `é•¿è¿ç¦æ‰‹ (${longChain}è¿)`;
                }
                
                // é»‘æ£‹çš„å…¶ä»–ç¦æ‰‹
                if (player === 1 && !isForbidden) {
                    const threeCount = this.countLiveThrees(row, col);
                    const fourCount = this.countFours(row, col);
                    
                    if (threeCount >= 2) {
                        isForbidden = true;
                        reason = `ä¸‰ä¸‰ç¦æ‰‹ (${threeCount}ä¸ªæ´»ä¸‰)`;
                    } else if (fourCount >= 2) {
                        isForbidden = true;
                        reason = `å››å››ç¦æ‰‹ (${fourCount}ä¸ªå››)`;
                    } else if (fourCount >= 1 && threeCount >= 2) {
                        isForbidden = true;
                        reason = `å››ä¸‰ä¸‰ç¦æ‰‹`;
                    }
                }
                
                this.board[row][col] = 0;
                
                if (isForbidden) {
                    this.showForbiddenWarning(reason);
                }
                
                return isForbidden;
            }
            
            checkLongChain(row, col, player) {
                let maxLength = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    let length = 1;
                    
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        length++;
                        r += dr;
                        c += dc;
                    }
                    
                    r = row - dr;
                    c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        length++;
                        r -= dr;
                        c -= dc;
                    }
                    
                    maxLength = Math.max(maxLength, length);
                }
                
                return maxLength;
            }
            
            countLiveThrees(row, col) {
                let count = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    const pattern = this.getDirectionPatternExtended(row, col, dr, dc, 7);
                    const patternStr = pattern.map(cell => {
                        if (cell === 1) return '1';
                        if (cell === 0) return '0';
                        return 'x';
                    }).join('');
                    
                    if (this.containsLiveThree(patternStr)) {
                        count++;
                    }
                }
                
                return count;
            }
            
            countFours(row, col) {
                let count = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    const pattern = this.getDirectionPatternExtended(row, col, dr, dc, 6);
                    const patternStr = pattern.map(cell => {
                        if (cell === 1) return '1';
                        if (cell === 0) return '0';
                        return 'x';
                    }).join('');
                    
                    if (patternStr.includes('011110') || this.containsSleepFour(patternStr)) {
                        count++;
                    }
                }
                
                return count;
            }
            
            // ============ å…¶ä»–æ¸¸æˆæ–¹æ³• ============
            
            checkWin(row, col) {
                const player = this.board[row][col];
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                this.winningLine = [];
                
                for (const [dr, dc] of directions) {
                    let count = 1;
                    let winningLine = [{row, col}];
                    
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++;
                        winningLine.push({row: r, col: c});
                        r += dr;
                        c += dc;
                    }
                    
                    r = row - dr;
                    c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++;
                        winningLine.unshift({row: r, col: c});
                        r -= dr;
                        c -= dc;
                    }
                    
                    if (count >= 5) {
                        this.winningLine = winningLine;
                        return true;
                    }
                }
                
                return false;
            }
            
            showForbiddenWarning(reason) {
                this.forbiddenReason.textContent = reason;
                this.forbiddenWarning.style.display = 'block';
                
                setTimeout(() => {
                    this.forbiddenWarning.style.display = 'none';
                }, 3000);
            }
            
            showWarning(message) {
                this.forbiddenReason.textContent = message;
                this.forbiddenWarning.style.display = 'block';
                
                setTimeout(() => {
                    this.forbiddenWarning.style.display = 'none';
                }, 2000);
            }
            
            showWinMessage() {
                const winnerName = this.winner === 1 ? 'é»‘æ£‹ (ç©å®¶)' : 'ç™½æ£‹ (AI)';
                this.gameStatus.textContent = `${winnerName} è·èƒœ`;
                
                setTimeout(() => {
                    alert(`ğŸ‰ ${winnerName} è·èƒœï¼`);
                }, 100);
            }
            
            // ============ ç»˜å›¾æ–¹æ³• ============
            
            drawBoard() {
                const ctx = this.ctx;
                const size = this.boardSize;
                const cellSize = this.cellSize;
                const padding = this.padding;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);
                
                // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯
                ctx.fillStyle = '#f0d9b5';
                ctx.fillRect(padding, padding, (size-1) * cellSize, (size-1) * cellSize);
                
                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < size; i++) {
                    // æ¨ªçº¿
                    ctx.beginPath();
                    ctx.moveTo(padding, i * cellSize + padding);
                    ctx.lineTo((size-1) * cellSize + padding, i * cellSize + padding);
                    ctx.stroke();
                    
                    // ç«–çº¿
                    ctx.beginPath();
                    ctx.moveTo(i * cellSize + padding, padding);
                    ctx.lineTo(i * cellSize + padding, (size-1) * cellSize + padding);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½
                const stars = [[3,3], [3,11], [7,7], [11,3], [11,11]];
                ctx.fillStyle = '#000';
                stars.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(
                        x * cellSize + padding,
                        y * cellSize + padding,
                        4, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
                
                // ç»˜åˆ¶æ£‹å­
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawStone(j, i, this.board[i][j]);
                        }
                    }
                }
                
                // ç»˜åˆ¶è·èƒœè¿çº¿
                if (this.winningLine.length > 0) {
                    this.drawWinningLine();
                }
                
                // æ ‡è®°æœ€åä¸€æ­¥
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    this.drawLastMoveMarker(lastMove.col, lastMove.row);
                }
            }
            
            drawStone(x, y, player) {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const padding = this.padding;
                const radius = cellSize * 0.42;
                
                const stoneX = x * cellSize + padding;
                const stoneY = y * cellSize + padding;
                
                ctx.beginPath();
                ctx.arc(stoneX, stoneY, radius, 0, Math.PI * 2);
                
                if (player === 1) {
                    // é»‘æ£‹
                    const gradient = ctx.createRadialGradient(
                        stoneX - 3, stoneY - 3, 0,
                        stoneX, stoneY, radius
                    );
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else {
                    // ç™½æ£‹
                    const gradient = ctx.createRadialGradient(
                        stoneX - 3, stoneY - 3, 0,
                        stoneX, stoneY, radius
                    );
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                ctx.fill();
            }
            
            drawWinningLine() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const padding = this.padding;
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                this.winningLine.forEach((pos, index) => {
                    const x = pos.col * cellSize + padding;
                    const y = pos.row * cellSize + padding;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
            
            drawLastMoveMarker(x, y) {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const padding = this.padding;
                
                const markerX = x * cellSize + padding;
                const markerY = y * cellSize + padding;
                
                ctx.beginPath();
                ctx.arc(markerX, markerY, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
            }
            
            undoMove() {
                if (this.gameOver || this.moveHistory.length === 0 || this.aiThinking) return;
                
                const lastMove = this.moveHistory.pop();
                this.board[lastMove.row][lastMove.col] = 0;
                
                this.gameOver = false;
                this.winner = null;
                this.winningLine = [];
                
                this.currentPlayer = lastMove.player;
                
                this.drawBoard();
                this.updateStatus();
                this.updateHistory();
            }
            
            resetGame() {
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.winningLine = [];
                this.aiThinking = false;
                
                this.drawBoard();
                this.updateStatus();
                this.updateHistory();
                this.forbiddenWarning.style.display = 'none';
                this.aiThinkingDiv.style.display = 'none';
                this.aiStatsDiv.style.display = 'none';
            }
            
            updateStatus() {
                if (this.gameOver) {
                    const winnerName = this.winner === 1 ? 'é»‘æ£‹ (ç©å®¶)' : 'ç™½æ£‹ (AI)';
                    this.gameStatus.textContent = `${winnerName} è·èƒœ`;
                    this.currentPlayerText.textContent = 'æ¸¸æˆç»“æŸ';
                } else {
                    if (this.currentPlayer === 1) {
                        this.currentPlayerText.textContent = 'é»‘æ£‹ (ç©å®¶)';
                        this.currentPlayerIndicator.className = 'player-indicator black-indicator';
                        this.currentPlayerIndicator.textContent = 'â—';
                        this.gameStatus.textContent = 'è½®åˆ°ç©å®¶èµ°æ£‹';
                    } else {
                        this.currentPlayerText.textContent = 'ç™½æ£‹ (AI)';
                        this.currentPlayerIndicator.className = 'player-indicator white-indicator';
                        this.currentPlayerIndicator.textContent = 'â—‹';
                        this.gameStatus.textContent = 'ç­‰å¾…AIæ€è€ƒ...';
                    }
                }
            }
            
            updateHistory() {
                this.historyList.innerHTML = '';
                
                for (let i = 0; i < this.moveHistory.length; i++) {
                    const move = this.moveHistory[i];
                    const historyItem = document.createElement('div');
                    historyItem.className = `history-item ${move.isAIMove ? 'ai-move' : ''}`;
                    
                    const playerText = move.player === 1 ? 'é»‘' : 'ç™½';
                    const moveType = move.isAIMove ? '(AI)' : '(ç©å®¶)';
                    
                    historyItem.innerHTML = `
                        <span>ç¬¬${move.moveNumber}æ‰‹: ${playerText}æ£‹ ${moveType}</span>
                        <span>(${move.col}, ${move.row})</span>
                    `;
                    
                    this.historyList.appendChild(historyItem);
                }
                
                // æ»šåŠ¨åˆ°åº•éƒ¨
                this.historyList.scrollTop = this.historyList.scrollHeight;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
        window.addEventListener('DOMContentLoaded', () => {
            const game = new ProfessionalGomokuAI();
            window.game = game;
        });
    </script>
</body>
</html>
