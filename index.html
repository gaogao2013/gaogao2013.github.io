<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏ì‰∏ö‰∫îÂ≠êÊ£ãAI - Minimax Alpha-Beta‰ºòÂåñÁâà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            color: #666;
            font-size: 1.1em;
        }
        
        .game-area {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .left-panel {
            flex: 2;
            min-width: 500px;
        }
        
        .right-panel {
            flex: 1;
            min-width: 300px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f0f7ff, #e3f2fd);
            border-radius: 10px;
            border-left: 5px solid #2196F3;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .player-indicator {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.3em;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }
        
        .black-indicator {
            background: linear-gradient(135deg, #333, #000);
            color: white;
            border: 3px solid #666;
        }
        
        .white-indicator {
            background: linear-gradient(135deg, #fff, #f5f5f5);
            color: #333;
            border: 3px solid #ddd;
        }
        
        .board-container {
            position: relative;
            background: linear-gradient(135deg, #deb887, #cd853f);
            padding: 25px;
            border-radius: 15px;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
        }
        
        #boardCanvas {
            display: block;
            background: #f0d9b5;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .ai-thinking {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
            align-items: center;
            gap: 15px;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .forbidden-warning {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            border: 2px solid #f44336;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 14px 28px;
            font-size: 1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .primary-btn {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, #2196F3, #1565C0);
            color: white;
        }
        
        .ai-btn {
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
            color: white;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .ai-controls {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .ai-controls h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ai-level-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .level-btn {
            flex: 1;
            padding: 12px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .level-btn:hover {
            background: #e3f2fd;
            border-color: #2196F3;
        }
        
        .level-btn.active {
            background: #2196F3;
            color: white;
            border-color: #1565C0;
            font-weight: bold;
        }
        
        .value-table {
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .value-table h4 {
            color: #333;
            margin-bottom: 10px;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        
        .value-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .value-item:last-child {
            border-bottom: none;
        }
        
        .pattern-name {
            font-weight: bold;
        }
        
        .pattern-value {
            color: #2196F3;
            font-weight: bold;
        }
        
        .move-history {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
        }
        
        .history-title {
            color: #333;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #2196F3;
        }
        
        .history-item.ai-move {
            border-left-color: #9C27B0;
            background: #f3e5f5;
        }
        
        .ai-stats {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9em;
            color: #666;
        }
        
        @media (max-width: 1100px) {
            .game-area {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                min-width: 100%;
            }
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            #boardCanvas {
                width: 350px !important;
                height: 350px !important;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ ‰∏ì‰∏ö‰∫îÂ≠êÊ£ãAI - Minimax Alpha-Beta‰ºòÂåñÁâà</h1>
            <p class="subtitle">Êô∫ËÉΩÊêúÁ¥¢ÁÆóÊ≥ï + ÂÆåÊï¥Á¶ÅÊâãËßÑÂàô + Ê∑±Â∫¶ÊÄùËÄÉÁ≠ñÁï•</p>
        </div>
        
        <div class="game-area">
            <div class="left-panel">
                <div class="game-info">
                    <div class="player-info">
                        <div class="player-indicator black-indicator" id="currentPlayerIndicator">‚óè</div>
                        <div>
                            <div id="currentPlayerText">ÈªëÊ£ã (Áé©ÂÆ∂)</div>
                            <div id="gameStatus" style="font-size: 0.9em; color: #666;">Ê∏∏Êàè‰∏≠...</div>
                        </div>
                    </div>
                    <div id="scoreInfo" style="font-weight: bold; color: #2196F3;">
                        Minimax AI | Ê∑±Â∫¶: 4
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <div class="board-container">
                        <canvas id="boardCanvas" width="450" height="450"></canvas>
                    </div>
                </div>
                
                <div class="ai-thinking" id="aiThinking">
                    <div class="spinner"></div>
                    <span>ü§î AIÊ≠£Âú®ÊÄùËÄÉ‰∏≠... Ê∑±Â∫¶: <span id="aiDepth">4</span></span>
                </div>
                
                <div class="forbidden-warning" id="forbiddenWarning">
                    <strong>‚ùå Á¶ÅÊâãÈòªÊ≠¢ÔºÅ</strong>
                    <span id="forbiddenReason">Ê≠§‰ΩçÁΩÆËøùÂèçÁ¶ÅÊâãËßÑÂàô</span>
                </div>
                
                <div class="controls">
                    <button class="primary-btn" id="restartBtn">üîÑ ÈáçÊñ∞ÂºÄÂßã</button>
                    <button class="secondary-btn" id="undoBtn">‚Ü©Ô∏è ÊÇîÊ£ã‰∏ÄÊ≠•</button>
                    <button class="ai-btn" id="aiMoveBtn">ü§ñ AIËµ∞‰∏ÄÊ≠•</button>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="ai-controls">
                    <h3>‚öôÔ∏è AIËÆæÁΩÆ</h3>
                    
                    <div class="ai-level-selector">
                        <div class="level-btn active" data-level="2">‰∏≠Á≠â (Ê∑±Â∫¶4)</div>
                        <div class="level-btn" data-level="1">ÁÆÄÂçï (Ê∑±Â∫¶2)</div>
                        <div class="level-btn" data-level="3">Âõ∞Èöæ (Ê∑±Â∫¶6)</div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label style="display: block; margin-bottom: 8px; color: #666;">
                            <input type="checkbox" id="autoAi" checked> Ëá™Âä®AIÂØπÊàò
                        </label>
                        <label style="display: block; margin-bottom: 8px; color: #666;">
                            <input type="checkbox" id="showAnalysis"> ÊòæÁ§∫ÂàÜÊûê‰ø°ÊÅØ
                        </label>
                    </div>
                </div>
                
                <div class="value-table">
                    <h4>üìä AIËØÑ‰º∞ÊùÉÈáç (Minimax‰ºòÂåñ)</h4>
                    <div class="value-item">
                        <span class="pattern-name">Ëøû‰∫î (ËÉúÂà©)</span>
                        <span class="pattern-value">+1000000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">Ê¥ªÂõõ</span>
                        <span class="pattern-value">+50000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">ÂÜ≤Âõõ</span>
                        <span class="pattern-value">+10000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">Ê¥ª‰∏â</span>
                        <span class="pattern-value">+5000</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">Áú†‰∏â</span>
                        <span class="pattern-value">+500</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">Ê¥ª‰∫å</span>
                        <span class="pattern-value">+200</span>
                    </div>
                    <div class="value-item">
                        <span class="pattern-name">Âèå‰∏â</span>
                        <span class="pattern-value">+20000</span>
                    </div>
                </div>
                
                <div id="aiStats" class="ai-stats" style="display: none;">
                    <div><strong>AIÊÄùËÄÉÁªüËÆ°Ôºö</strong></div>
                    <div id="statsContent"></div>
                </div>
                
                <div class="move-history">
                    <div class="history-title">üìù Ëµ∞Ê£ãËÆ∞ÂΩï</div>
                    <div id="historyList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ProfessionalGomokuAI {
            constructor() {
                // Ê£ãÁõòÂèÇÊï∞
                this.boardSize = 15;
                this.cellSize = 30;
                this.padding = 15;
                this.canvasSize = this.boardSize * this.cellSize + this.padding * 2;
                
                // Ê∏∏ÊàèÁä∂ÊÄÅ
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1; // 1: Áé©ÂÆ∂(Èªë), 2: AI(ÁôΩ)
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.winningLine = [];
                
                // AIÂèÇÊï∞
                this.aiLevel = 2;
                this.aiThinking = false;
                this.autoAI = true;
                this.showAnalysis = false;
                
                // ÊÄßËÉΩÁªüËÆ°
                this.searchNodeCount = 0;
                this.pruneCount = 0;
                this.searchStartTime = 0;
                
                // Ê£ãÂûã‰ª∑ÂÄºË°®Ôºà‰ºòÂåñÁâàÔºâ
                this.patternScores = {
                    FIVE: 1000000,          // Ëøû‰∫îËÉúÂà©
                    LIVE_FOUR: 50000,       // Ê¥ªÂõõ
                    SLEEP_FOUR: 10000,      // ÂÜ≤Âõõ
                    LIVE_THREE: 5000,       // Ê¥ª‰∏â
                    SLEEP_THREE: 500,       // Áú†‰∏â
                    LIVE_TWO: 200,          // Ê¥ª‰∫å
                    SLEEP_TWO: 50,          // Áú†‰∫å
                    
                    OPPONENT_LIVE_FOUR: 80000,     // ÂØπÊñπÊ¥ªÂõõ
                    OPPONENT_SLEEP_FOUR: 40000,    // ÂØπÊñπÂÜ≤Âõõ
                    OPPONENT_LIVE_THREE: 15000,    // ÂØπÊñπÊ¥ª‰∏â
                    
                    DOUBLE_THREE: 20000,           // Âèå‰∏â
                    FOUR_THREE: 60000,             // Âõõ‰∏â
                };
                
                // ÈöæÂ∫¶ÂØπÂ∫îÁöÑÊêúÁ¥¢Ê∑±Â∫¶
                this.depthByLevel = {1: 2, 2: 4, 3: 6};
                
                // ÂàùÂßãÂåñ
                this.initialize();
            }
            
            initialize() {
                // Ëé∑ÂèñDOMÂÖÉÁ¥†
                this.canvas = document.getElementById('boardCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentPlayerText = document.getElementById('currentPlayerText');
                this.currentPlayerIndicator = document.getElementById('currentPlayerIndicator');
                this.gameStatus = document.getElementById('gameStatus');
                this.scoreInfo = document.getElementById('scoreInfo');
                this.forbiddenWarning = document.getElementById('forbiddenWarning');
                this.forbiddenReason = document.getElementById('forbiddenReason');
                this.aiThinkingDiv = document.getElementById('aiThinking');
                this.aiDepthSpan = document.getElementById('aiDepth');
                this.historyList = document.getElementById('historyList');
                this.aiStatsDiv = document.getElementById('aiStats');
                this.statsContent = document.getElementById('statsContent');
                
                // ËÆæÁΩÆcanvasÂ∞∫ÂØ∏
                this.canvas.width = this.canvasSize;
                this.canvas.height = this.canvasSize;
                
                // ÁªëÂÆö‰∫ã‰ª∂
                this.setupEventListeners();
                
                // ÂºÄÂßãÊ∏∏Êàè
                this.resetGame();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                document.getElementById('restartBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('aiMoveBtn').addEventListener('click', () => this.makeAIMove());
                
                // ÈöæÂ∫¶ÈÄâÊã©
                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.aiLevel = parseInt(btn.dataset.level);
                        this.aiDepthSpan.textContent = this.depthByLevel[this.aiLevel];
                        this.scoreInfo.textContent = `Minimax AI | Ê∑±Â∫¶: ${this.depthByLevel[this.aiLevel]}`;
                    });
                });
                
                // Ëá™Âä®AIÂºÄÂÖ≥
                document.getElementById('autoAi').addEventListener('change', (e) => {
                    this.autoAI = e.target.checked;
                });
                
                // ÂàÜÊûêÊòæÁ§∫ÂºÄÂÖ≥
                document.getElementById('showAnalysis').addEventListener('change', (e) => {
                    this.showAnalysis = e.target.checked;
                });
            }
            
            // ============ Ê∏∏ÊàèÊ†∏ÂøÉÈÄªËæë ============
            
            handleClick(e) {
                if (this.gameOver || this.aiThinking || this.currentPlayer !== 1) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const col = Math.round((x - this.padding) / this.cellSize);
                const row = Math.round((y - this.padding) / this.cellSize);
                
                if (row >= 0 && row < this.boardSize && col >= 0 && col < this.boardSize) {
                    this.tryMakeMove(row, col);
                }
            }
            
            tryMakeMove(row, col) {
                if (this.board[row][col] !== 0) {
                    this.showWarning("ËØ•‰ΩçÁΩÆÂ∑≤ÊúâÊ£ãÂ≠êÔºÅ");
                    return false;
                }
                
                // Ê£ÄÊü•Á¶ÅÊâã
                if (this.isForbiddenMove(row, col, this.currentPlayer)) {
                    return false;
                }
                
                this.executeMove(row, col, false);
                return true;
            }
            
            executeMove(row, col, isAIMove = false) {
                // ËÆ∞ÂΩïËµ∞Ê£ã
                const moveNumber = this.moveHistory.length + 1;
                this.moveHistory.push({
                    row, col,
                    player: this.currentPlayer,
                    moveNumber,
                    isAIMove,
                    timestamp: Date.now()
                });
                
                // ‰∏ãÊ£ã
                this.board[row][col] = this.currentPlayer;
                
                // Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩï
                this.updateHistory();
                
                // Ê£ÄÊü•ËÉúÂà©
                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.showWinMessage();
                    this.drawBoard();
                    return;
                }
                
                // ÂàáÊç¢Áé©ÂÆ∂
                this.currentPlayer = 3 - this.currentPlayer;
                
                // Êõ¥Êñ∞ÁïåÈù¢
                this.drawBoard();
                this.updateStatus();
                
                // Â¶ÇÊûúÊòØÁé©ÂÆ∂Ëµ∞Ê£ã‰∏îÂºÄÂêØ‰∫ÜËá™Âä®AIÔºåËÆ©AIËµ∞Ê£ã
                if (!isAIMove && this.autoAI && this.currentPlayer === 2 && !this.gameOver) {
                    setTimeout(() => this.makeAIMove(), 300);
                }
            }
            
            // ============ Minimax Alpha-Beta AIÊ†∏ÂøÉÁÆóÊ≥ï ============
            
            async makeAIMove() {
                if (this.gameOver || this.currentPlayer !== 2 || this.aiThinking) return;
                
                this.aiThinking = true;
                this.aiThinkingDiv.style.display = 'flex';
                
                // ÈáçÁΩÆÁªüËÆ°
                this.searchNodeCount = 0;
                this.pruneCount = 0;
                this.searchStartTime = Date.now();
                
                try {
                    const depth = this.depthByLevel[this.aiLevel];
                    const bestMove = this.findBestMoveWithMinimax(depth);
                    
                    if (bestMove) {
                        this.executeMove(bestMove.row, bestMove.col, true);
                        
                        // ÊòæÁ§∫ÁªüËÆ°‰ø°ÊÅØ
                        if (this.showAnalysis) {
                            this.showAITimings();
                        }
                    }
                } catch (error) {
                    console.error('AIÊÄùËÄÉÂá∫Èîô:', error);
                    // Âá∫ÈîôÊó∂‰ΩøÁî®ÁÆÄÂçïÁÆóÊ≥ï
                    const simpleMove = this.findBestMoveSimple();
                    if (simpleMove) {
                        this.executeMove(simpleMove.row, simpleMove.col, true);
                    }
                } finally {
                    this.aiThinking = false;
                    this.aiThinkingDiv.style.display = 'none';
                }
            }
            
            findBestMoveWithMinimax(maxDepth) {
                // 1. Ê£ÄÊü•Á´ãÂç≥Ëé∑ËÉú
                const winMove = this.findImmediateWin(2);
                if (winMove) return winMove;
                
                // 2. Á¥ßÊÄ•Èò≤ÂÆà
                const blockMove = this.findImmediateWin(1);
                if (blockMove && !this.isForbiddenMove(blockMove.row, blockMove.col, 2)) {
                    return blockMove;
                }
                
                // 3. ‰ΩøÁî®Minimax Alpha-BetaÊêúÁ¥¢
                const candidateMoves = this.getCandidateMovesOptimized(2);
                
                let bestScore = -Infinity;
                let bestMove = null;
                let alpha = -Infinity;
                let beta = Infinity;
                
                for (const move of candidateMoves) {
                    const {row, col} = move;
                    
                    // Ë∑≥ËøáÁ¶ÅÊâã‰ΩçÁΩÆ
                    if (this.isForbiddenMove(row, col, 2)) continue;
                    
                    // Â∞ùËØïËµ∞Ê£ã
                    this.board[row][col] = 2;
                    
                    // Alpha-BetaÂâ™ÊûùÊêúÁ¥¢
                    const score = this.minimaxAlphaBeta(
                        maxDepth - 1, 
                        alpha, 
                        beta, 
                        false, // ‰∏ã‰∏ÄÊ≠•ÊòØÂØπÊâã
                        1      // ÂØπÊâãÊòØÈªëÊ£ã
                    );
                    
                    // Êí§ÈîÄËµ∞Ê£ã
                    this.board[row][col] = 0;
                    
                    // Êõ¥Êñ∞ÊúÄ‰Ω≥Ëµ∞Ê≥ï
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = {row, col};
                        alpha = Math.max(alpha, score);
                    }
                    
                    if (beta <= alpha) {
                        this.pruneCount++;
                        break; // BetaÂâ™Êûù
                    }
                }
                
                return bestMove;
            }
            
            minimaxAlphaBeta(depth, alpha, beta, isMaximizing, player) {
                this.searchNodeCount++;
                
                // ÁªàÊ≠¢Êù°‰ª∂ÔºöËææÂà∞Ê∑±Â∫¶ÈôêÂà∂ÊàñÊ∏∏ÊàèÁªìÊùü
                if (depth === 0 || this.isGameTerminal()) {
                    return this.evaluateBoard(player === 2);
                }
                
                const currentPlayer = isMaximizing ? 2 : 1;
                const candidateMoves = this.getCandidateMovesOptimized(currentPlayer);
                
                if (isMaximizing) {
                    let maxEval = -Infinity;
                    
                    for (const move of candidateMoves) {
                        const {row, col} = move;
                        
                        if (this.isForbiddenMove(row, col, currentPlayer)) continue;
                        
                        this.board[row][col] = currentPlayer;
                        
                        const evaluation = this.minimaxAlphaBeta(
                            depth - 1, 
                            alpha, 
                            beta, 
                            false, 
                            3 - currentPlayer
                        );
                        
                        this.board[row][col] = 0;
                        
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        
                        if (beta <= alpha) {
                            this.pruneCount++;
                            break; // BetaÂâ™Êûù
                        }
                    }
                    
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    
                    for (const move of candidateMoves) {
                        const {row, col} = move;
                        
                        if (this.isForbiddenMove(row, col, currentPlayer)) continue;
                        
                        this.board[row][col] = currentPlayer;
                        
                        const evaluation = this.minimaxAlphaBeta(
                            depth - 1, 
                            alpha, 
                            beta, 
                            true, 
                            3 - currentPlayer
                        );
                        
                        this.board[row][col] = 0;
                        
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        
                        if (beta <= alpha) {
                            this.pruneCount++;
                            break; // AlphaÂâ™Êûù
                        }
                    }
                    
                    return minEval;
                }
            }
            
            findImmediateWin(player) {
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            this.board[i][j] = player;
                            
                            if (this.checkWin(i, j)) {
                                this.board[i][j] = 0;
                                return {row: i, col: j};
                            }
                            
                            this.board[i][j] = 0;
                        }
                    }
                }
                return null;
            }
            
            isGameTerminal() {
                // Ê£ÄÊü•ÊòØÂê¶Êúâ‰∫îËøû
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            const player = this.board[i][j];
                            const directions = [[0,1], [1,0], [1,1], [1,-1]];
                            
                            for (const [dr, dc] of directions) {
                                let count = 1;
                                let r = i + dr, c = j + dc;
                                
                                while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                                       this.board[r][c] === player) {
                                    count++;
                                    r += dr;
                                    c += dc;
                                }
                                
                                r = i - dr;
                                c = j - dc;
                                while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                                       this.board[r][c] === player) {
                                    count++;
                                    r -= dr;
                                    c -= dc;
                                }
                                
                                if (count >= 5) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            evaluateBoard(isAITurn) {
                let score = 0;
                const aiPlayer = 2;
                const humanPlayer = 1;
                
                // ËØÑ‰º∞Êï¥‰∏™Ê£ãÁõò
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === aiPlayer) {
                            score += this.evaluatePosition(i, j, aiPlayer, true);
                        } else if (this.board[i][j] === humanPlayer) {
                            score -= this.evaluatePosition(i, j, humanPlayer, false) * 1.2;
                        }
                    }
                }
                
                return score;
            }
            
            evaluatePosition(row, col, player, isAI) {
                let score = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    const pattern = this.getDirectionPatternExtended(row, col, dr, dc, 9);
                    score += this.evaluatePattern(pattern, player, isAI);
                }
                
                // ‰ΩçÁΩÆ‰ºòÂäø
                const center = Math.floor(this.boardSize / 2);
                const dist = Math.abs(row - center) + Math.abs(col - center);
                score += (this.boardSize - dist) * 10;
                
                return score;
            }
            
            evaluatePattern(pattern, player, isAI) {
                const patternStr = pattern.map(cell => {
                    if (cell === player) return '1';
                    if (cell === 0) return '0';
                    return 'x';
                }).join('');
                
                let score = 0;
                
                // Ëøû‰∫î
                if (patternStr.includes('11111')) {
                    return this.patternScores.FIVE;
                }
                
                // Ê¥ªÂõõ
                if (patternStr.includes('011110')) {
                    score += isAI ? this.patternScores.LIVE_FOUR : this.patternScores.OPPONENT_LIVE_FOUR;
                }
                
                // ÂÜ≤Âõõ
                if (this.containsSleepFour(patternStr)) {
                    score += isAI ? this.patternScores.SLEEP_FOUR : this.patternScores.OPPONENT_SLEEP_FOUR;
                }
                
                // Ê¥ª‰∏â
                if (this.containsLiveThree(patternStr)) {
                    score += isAI ? this.patternScores.LIVE_THREE : this.patternScores.OPPONENT_LIVE_THREE;
                }
                
                // Áú†‰∏â
                if (this.containsSleepThree(patternStr)) {
                    score += this.patternScores.SLEEP_THREE;
                }
                
                // Ê¥ª‰∫å
                if (this.containsLiveTwo(patternStr)) {
                    score += this.patternScores.LIVE_TWO;
                }
                
                return score;
            }
            
            containsSleepFour(patternStr) {
                const sleepFourPatterns = [
                    '011112', '211110',     // ÂçïËæπÂÜ≤Âõõ
                    '10111', '11101', '11011'  // Ë∑≥ÂÜ≤Âõõ
                ];
                
                for (const pattern of sleepFourPatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            containsLiveThree(patternStr) {
                const liveThreePatterns = [
                    '01110',     // ‰∏≠Èó¥Ê¥ª‰∏â
                    '010110',    // Ë∑≥Ê¥ª‰∏â
                    '011010',    // Ë∑≥Ê¥ª‰∏â
                    '0011100'    // Âè¶‰∏ÄÁßçÊ¥ª‰∏â
                ];
                
                for (const pattern of liveThreePatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            containsSleepThree(patternStr) {
                const sleepThreePatterns = [
                    '01112', '21110',
                    '010112', '211010',
                    '011012', '210110'
                ];
                
                for (const pattern of sleepThreePatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            containsLiveTwo(patternStr) {
                const liveTwoPatterns = [
                    '001100', '01010', '010010',
                    '0010100', '00011000'
                ];
                
                for (const pattern of liveTwoPatterns) {
                    if (patternStr.includes(pattern)) {
                        return true;
                    }
                }
                return false;
            }
            
            getDirectionPatternExtended(row, col, dr, dc, length) {
                const pattern = [];
                const offset = Math.floor(length / 2);
                
                for (let i = -offset; i <= offset; i++) {
                    const r = row + dr * i;
                    const c = col + dc * i;
                    
                    if (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize) {
                        pattern.push(this.board[r][c]);
                    } else {
                        pattern.push(-1); // ËæπÁïåÂ§ñ
                    }
                }
                
                return pattern;
            }
            
            getCandidateMovesOptimized(player) {
                const moves = [];
                const scores = [];
                const visited = new Set();
                
                // ÊêúÁ¥¢ÂçäÂæÑ
                const searchRadius = this.aiLevel === 3 ? 3 : 2;
                
                // ‰ºòÂÖàÊêúÁ¥¢Â∑≤ÊúâÊ£ãÂ≠êÂë®Âõ¥
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            for (let di = -searchRadius; di <= searchRadius; di++) {
                                for (let dj = -searchRadius; dj <= searchRadius; dj++) {
                                    const ni = i + di;
                                    const nj = j + dj;
                                    
                                    if (ni >= 0 && ni < this.boardSize && nj >= 0 && nj < this.boardSize &&
                                        this.board[ni][nj] === 0) {
                                        const key = `${ni},${nj}`;
                                        if (!visited.has(key)) {
                                            visited.add(key);
                                            // ËÆ°ÁÆó‰ΩçÁΩÆÂàÜÊï∞Áî®‰∫éÊéíÂ∫è
                                            const score = this.evaluateMovePotential(ni, nj, player);
                                            moves.push({row: ni, col: nj});
                                            scores.push(score);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Â¶ÇÊûúÊ≤°ÊúâÂÄôÈÄâ‰ΩçÁΩÆÔºåÈÄâÊã©‰∏≠ÂøÉÂå∫Âüü
                if (moves.length === 0) {
                    const center = Math.floor(this.boardSize / 2);
                    for (let i = center - 1; i <= center + 1; i++) {
                        for (let j = center - 1; j <= center + 1; j++) {
                            if (i >= 0 && i < this.boardSize && j >= 0 && j < this.boardSize &&
                                this.board[i][j] === 0) {
                                moves.push({row: i, col: j});
                            }
                        }
                    }
                }
                
                // Ê†πÊçÆÂàÜÊï∞ÊéíÂ∫èÔºàÊèêÈ´òAlpha-BetaÊïàÁéáÔºâ
                const sortedIndices = scores.map((_, index) => index)
                    .sort((a, b) => scores[b] - scores[a]);
                
                return sortedIndices.map(idx => moves[idx]);
            }
            
            evaluateMovePotential(row, col, player) {
                let score = 0;
                
                // ‰∏≠ÂøÉ‰ºòÂäø
                const center = Math.floor(this.boardSize / 2);
                const dist = Math.abs(row - center) + Math.abs(col - center);
                score += (this.boardSize - dist) * 10;
                
                // Âë®ËæπÊ£ãÂ≠êÂΩ±Âìç
                for (let i = Math.max(0, row - 2); i <= Math.min(this.boardSize - 1, row + 2); i++) {
                    for (let j = Math.max(0, col - 2); j <= Math.min(this.boardSize - 1, col + 2); j++) {
                        if (this.board[i][j] === player) {
                            const distance = Math.abs(i - row) + Math.abs(j - col);
                            score += (3 - distance) * 50;
                        } else if (this.board[i][j] === 3 - player) {
                            const distance = Math.abs(i - row) + Math.abs(j - col);
                            score += (3 - distance) * 30;
                        }
                    }
                }
                
                return score;
            }
            
            findBestMoveSimple() {
                // ÁÆÄÂçïÁöÑÂ®ÅËÉÅÊ£ÄÊµã‰Ωú‰∏∫Â§áÁî®
                const winMove = this.findImmediateWin(2);
                if (winMove) return winMove;
                
                const blockMove = this.findImmediateWin(1);
                if (blockMove && !this.isForbiddenMove(blockMove.row, blockMove.col, 2)) {
                    return blockMove;
                }
                
                // ÈöèÊú∫ÈÄâÊã©‰∏Ä‰∏™ÂÄôÈÄâ‰ΩçÁΩÆ
                const candidateMoves = this.getCandidateMovesOptimized(2);
                if (candidateMoves.length > 0) {
                    return candidateMoves[0];
                }
                
                return null;
            }
            
            showAITimings() {
                const searchTime = Date.now() - this.searchStartTime;
                
                this.statsContent.innerHTML = `
                    <div>ÊêúÁ¥¢Êó∂Èó¥: ${searchTime}ms</div>
                    <div>ÊêúÁ¥¢ËäÇÁÇπÊï∞: ${this.searchNodeCount}</div>
                    <div>Ââ™ÊûùÊ¨°Êï∞: ${this.pruneCount}</div>
                    <div>ÊêúÁ¥¢Ê∑±Â∫¶: ${this.depthByLevel[this.aiLevel]}</div>
                `;
                
                this.aiStatsDiv.style.display = 'block';
                
                // 5ÁßíÂêéÈöêËóèÁªüËÆ°‰ø°ÊÅØ
                setTimeout(() => {
                    if (this.aiStatsDiv) {
                        this.aiStatsDiv.style.display = 'none';
                    }
                }, 5000);
            }
            
            // ============ Á¶ÅÊâãÊ£ÄÊµã ============
            isForbiddenMove(row, col, player) {
                if (this.board[row][col] !== 0) return false;
                
                this.board[row][col] = player;
                
                let isForbidden = false;
                let reason = "";
                
                // ÈïøËøûÁ¶ÅÊâã
                const longChain = this.checkLongChain(row, col, player);
                if (longChain > 5) {
                    isForbidden = true;
                    reason = `ÈïøËøûÁ¶ÅÊâã (${longChain}Ëøû)`;
                }
                
                // ÈªëÊ£ãÁöÑÂÖ∂‰ªñÁ¶ÅÊâã
                if (player === 1 && !isForbidden) {
                    const threeCount = this.countLiveThrees(row, col);
                    const fourCount = this.countFours(row, col);
                    
                    if (threeCount >= 2) {
                        isForbidden = true;
                        reason = `‰∏â‰∏âÁ¶ÅÊâã (${threeCount}‰∏™Ê¥ª‰∏â)`;
                    } else if (fourCount >= 2) {
                        isForbidden = true;
                        reason = `ÂõõÂõõÁ¶ÅÊâã (${fourCount}‰∏™Âõõ)`;
                    } else if (fourCount >= 1 && threeCount >= 2) {
                        isForbidden = true;
                        reason = `Âõõ‰∏â‰∏âÁ¶ÅÊâã`;
                    }
                }
                
                this.board[row][col] = 0;
                
                if (isForbidden) {
                    this.showForbiddenWarning(reason);
                }
                
                return isForbidden;
            }
            
            checkLongChain(row, col, player) {
                let maxLength = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    let length = 1;
                    
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        length++;
                        r += dr;
                        c += dc;
                    }
                    
                    r = row - dr;
                    c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        length++;
                        r -= dr;
                        c -= dc;
                    }
                    
                    maxLength = Math.max(maxLength, length);
                }
                
                return maxLength;
            }
            
            countLiveThrees(row, col) {
                let count = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    const pattern = this.getDirectionPatternExtended(row, col, dr, dc, 7);
                    const patternStr = pattern.map(cell => {
                        if (cell === 1) return '1';
                        if (cell === 0) return '0';
                        return 'x';
                    }).join('');
                    
                    if (this.containsLiveThree(patternStr)) {
                        count++;
                    }
                }
                
                return count;
            }
            
            countFours(row, col) {
                let count = 0;
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dr, dc] of directions) {
                    const pattern = this.getDirectionPatternExtended(row, col, dr, dc, 6);
                    const patternStr = pattern.map(cell => {
                        if (cell === 1) return '1';
                        if (cell === 0) return '0';
                        return 'x';
                    }).join('');
                    
                    if (patternStr.includes('011110') || this.containsSleepFour(patternStr)) {
                        count++;
                    }
                }
                
                return count;
            }
            
            // ============ ÂÖ∂‰ªñÊ∏∏ÊàèÊñπÊ≥ï ============
            
            checkWin(row, col) {
                const player = this.board[row][col];
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                this.winningLine = [];
                
                for (const [dr, dc] of directions) {
                    let count = 1;
                    let winningLine = [{row, col}];
                    
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++;
                        winningLine.push({row: r, col: c});
                        r += dr;
                        c += dc;
                    }
                    
                    r = row - dr;
                    c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++;
                        winningLine.unshift({row: r, col: c});
                        r -= dr;
                        c -= dc;
                    }
                    
                    if (count >= 5) {
                        this.winningLine = winningLine;
                        return true;
                    }
                }
                
                return false;
            }
            
            showForbiddenWarning(reason) {
                this.forbiddenReason.textContent = reason;
                this.forbiddenWarning.style.display = 'block';
                
                setTimeout(() => {
                    this.forbiddenWarning.style.display = 'none';
                }, 3000);
            }
            
            showWarning(message) {
                this.forbiddenReason.textContent = message;
                this.forbiddenWarning.style.display = 'block';
                
                setTimeout(() => {
                    this.forbiddenWarning.style.display = 'none';
                }, 2000);
            }
            
            showWinMessage() {
                const winnerName = this.winner === 1 ? 'ÈªëÊ£ã (Áé©ÂÆ∂)' : 'ÁôΩÊ£ã (AI)';
                this.gameStatus.textContent = `${winnerName} Ëé∑ËÉú`;
                
                setTimeout(() => {
                    alert(`üéâ ${winnerName} Ëé∑ËÉúÔºÅ`);
                }, 100);
            }
            
            // ============ ÁªòÂõæÊñπÊ≥ï ============
            
            drawBoard() {
                const ctx = this.ctx;
                const size = this.boardSize;
                const cellSize = this.cellSize;
                const padding = this.padding;
                
                // Ê∏ÖÁ©∫ÁîªÂ∏É
                ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);
                
                // ÁªòÂà∂Ê£ãÁõòËÉåÊôØ
                ctx.fillStyle = '#f0d9b5';
                ctx.fillRect(padding, padding, (size-1) * cellSize, (size-1) * cellSize);
                
                // ÁªòÂà∂ÁΩëÊ†ºÁ∫ø
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < size; i++) {
                    // Ê®™Á∫ø
                    ctx.beginPath();
                    ctx.moveTo(padding, i * cellSize + padding);
                    ctx.lineTo((size-1) * cellSize + padding, i * cellSize + padding);
                    ctx.stroke();
                    
                    // Á´ñÁ∫ø
                    ctx.beginPath();
                    ctx.moveTo(i * cellSize + padding, padding);
                    ctx.lineTo(i * cellSize + padding, (size-1) * cellSize + padding);
                    ctx.stroke();
                }
                
                // ÁªòÂà∂Â§©ÂÖÉÂíåÊòü‰Ωç
                const stars = [[3,3], [3,11], [7,7], [11,3], [11,11]];
                ctx.fillStyle = '#000';
                stars.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(
                        x * cellSize + padding,
                        y * cellSize + padding,
                        4, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
                
                // ÁªòÂà∂Ê£ãÂ≠ê
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawStone(j, i, this.board[i][j]);
                        }
                    }
                }
                
                // ÁªòÂà∂Ëé∑ËÉúËøûÁ∫ø
                if (this.winningLine.length > 0) {
                    this.drawWinningLine();
                }
                
                // Ê†áËÆ∞ÊúÄÂêé‰∏ÄÊ≠•
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    this.drawLastMoveMarker(lastMove.col, lastMove.row);
                }
            }
            
            drawStone(x, y, player) {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const padding = this.padding;
                const radius = cellSize * 0.42;
                
                const stoneX = x * cellSize + padding;
                const stoneY = y * cellSize + padding;
                
                ctx.beginPath();
                ctx.arc(stoneX, stoneY, radius, 0, Math.PI * 2);
                
                if (player === 1) {
                    // ÈªëÊ£ã
                    const gradient = ctx.createRadialGradient(
                        stoneX - 3, stoneY - 3, 0,
                        stoneX, stoneY, radius
                    );
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else {
                    // ÁôΩÊ£ã
                    const gradient = ctx.createRadialGradient(
                        stoneX - 3, stoneY - 3, 0,
                        stoneX, stoneY, radius
                    );
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                ctx.fill();
            }
            
            drawWinningLine() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const padding = this.padding;
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                this.winningLine.forEach((pos, index) => {
                    const x = pos.col * cellSize + padding;
                    const y = pos.row * cellSize + padding;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
            
            drawLastMoveMarker(x, y) {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const padding = this.padding;
                
                const markerX = x * cellSize + padding;
                const markerY = y * cellSize + padding;
                
                ctx.beginPath();
                ctx.arc(markerX, markerY, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
            }
            
            undoMove() {
                if (this.gameOver || this.moveHistory.length === 0 || this.aiThinking) return;
                
                const lastMove = this.moveHistory.pop();
                this.board[lastMove.row][lastMove.col] = 0;
                
                this.gameOver = false;
                this.winner = null;
                this.winningLine = [];
                
                this.currentPlayer = lastMove.player;
                
                this.drawBoard();
                this.updateStatus();
                this.updateHistory();
            }
            
            resetGame() {
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.winningLine = [];
                this.aiThinking = false;
                
                this.drawBoard();
                this.updateStatus();
                this.updateHistory();
                this.forbiddenWarning.style.display = 'none';
                this.aiThinkingDiv.style.display = 'none';
                this.aiStatsDiv.style.display = 'none';
            }
            
            updateStatus() {
                if (this.gameOver) {
                    const winnerName = this.winner === 1 ? 'ÈªëÊ£ã (Áé©ÂÆ∂)' : 'ÁôΩÊ£ã (AI)';
                    this.gameStatus.textContent = `${winnerName} Ëé∑ËÉú`;
                    this.currentPlayerText.textContent = 'Ê∏∏ÊàèÁªìÊùü';
                } else {
                    if (this.currentPlayer === 1) {
                        this.currentPlayerText.textContent = 'ÈªëÊ£ã (Áé©ÂÆ∂)';
                        this.currentPlayerIndicator.className = 'player-indicator black-indicator';
                        this.currentPlayerIndicator.textContent = '‚óè';
                        this.gameStatus.textContent = 'ËΩÆÂà∞Áé©ÂÆ∂Ëµ∞Ê£ã';
                    } else {
                        this.currentPlayerText.textContent = 'ÁôΩÊ£ã (AI)';
                        this.currentPlayerIndicator.className = 'player-indicator white-indicator';
                        this.currentPlayerIndicator.textContent = '‚óã';
                        this.gameStatus.textContent = 'Á≠âÂæÖAIÊÄùËÄÉ...';
                    }
                }
            }
            
            updateHistory() {
                this.historyList.innerHTML = '';
                
                for (let i = 0; i < this.moveHistory.length; i++) {
                    const move = this.moveHistory[i];
                    const historyItem = document.createElement('div');
                    historyItem.className = `history-item ${move.isAIMove ? 'ai-move' : ''}`;
                    
                    const playerText = move.player === 1 ? 'Èªë' : 'ÁôΩ';
                    const moveType = move.isAIMove ? '(AI)' : '(Áé©ÂÆ∂)';
                    
                    historyItem.innerHTML = `
                        <span>Á¨¨${move.moveNumber}Êâã: ${playerText}Ê£ã ${moveType}</span>
                        <span>(${move.col}, ${move.row})</span>
                    `;
                    
                    this.historyList.appendChild(historyItem);
                }
                
                // ÊªöÂä®Âà∞Â∫ïÈÉ®
                this.historyList.scrollTop = this.historyList.scrollHeight;
            }
        }
        
        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñÊ∏∏Êàè
        window.addEventListener('DOMContentLoaded', () => {
            const game = new ProfessionalGomokuAI();
            window.game = game;
        });
    </script>
</body>
</html>
